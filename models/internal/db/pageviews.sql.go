// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pageviews.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const insertPageview = `-- name: InsertPageview :one
insert into
    pageviews (id, created_at, website_id, url, referrer, browser, os, device, country, language, screen_width, visitor_hash, country_code, country_name, city, region)
values
    ($1, now(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
returning id, created_at, website_id, url, referrer, browser, os, device, country, language, screen_width, visitor_hash, country_code, country_name, city, region
`

type InsertPageviewParams struct {
	ID          uuid.UUID
	WebsiteID   uuid.UUID
	Url         string
	Referrer    pgtype.Text
	Browser     pgtype.Text
	Os          pgtype.Text
	Device      pgtype.Text
	Country     pgtype.Text
	Language    pgtype.Text
	ScreenWidth pgtype.Int4
	VisitorHash pgtype.Text
	CountryCode pgtype.Text
	CountryName pgtype.Text
	City        pgtype.Text
	Region      pgtype.Text
}

// InsertPageview
//
//	insert into
//	    pageviews (id, created_at, website_id, url, referrer, browser, os, device, country, language, screen_width, visitor_hash, country_code, country_name, city, region)
//	values
//	    ($1, now(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
//	returning id, created_at, website_id, url, referrer, browser, os, device, country, language, screen_width, visitor_hash, country_code, country_name, city, region
func (q *Queries) InsertPageview(ctx context.Context, db DBTX, arg InsertPageviewParams) (Pageview, error) {
	row := db.QueryRow(ctx, insertPageview,
		arg.ID,
		arg.WebsiteID,
		arg.Url,
		arg.Referrer,
		arg.Browser,
		arg.Os,
		arg.Device,
		arg.Country,
		arg.Language,
		arg.ScreenWidth,
		arg.VisitorHash,
		arg.CountryCode,
		arg.CountryName,
		arg.City,
		arg.Region,
	)
	var i Pageview
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.WebsiteID,
		&i.Url,
		&i.Referrer,
		&i.Browser,
		&i.Os,
		&i.Device,
		&i.Country,
		&i.Language,
		&i.ScreenWidth,
		&i.VisitorHash,
		&i.CountryCode,
		&i.CountryName,
		&i.City,
		&i.Region,
	)
	return i, err
}

const queryBounceCount = `-- name: QueryBounceCount :one
SELECT count(*)::bigint AS bounce_visitors
FROM (
    SELECT visitor_hash
    FROM pageviews
    WHERE website_id = $1
      AND created_at BETWEEN $2::timestamptz AND $3::timestamptz
      AND visitor_hash IS NOT NULL
    GROUP BY visitor_hash
    HAVING count(*) = 1
) AS single_page_visitors
`

type QueryBounceCountParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

// QueryBounceCount
//
//	SELECT count(*)::bigint AS bounce_visitors
//	FROM (
//	    SELECT visitor_hash
//	    FROM pageviews
//	    WHERE website_id = $1
//	      AND created_at BETWEEN $2::timestamptz AND $3::timestamptz
//	      AND visitor_hash IS NOT NULL
//	    GROUP BY visitor_hash
//	    HAVING count(*) = 1
//	) AS single_page_visitors
func (q *Queries) QueryBounceCount(ctx context.Context, db DBTX, arg QueryBounceCountParams) (int64, error) {
	row := db.QueryRow(ctx, queryBounceCount, arg.WebsiteID, arg.StartDate, arg.EndDate)
	var bounce_visitors int64
	err := row.Scan(&bounce_visitors)
	return bounce_visitors, err
}

const queryBrowserBreakdown = `-- name: QueryBrowserBreakdown :many
select browser, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
group by browser order by views desc
`

type QueryBrowserBreakdownParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryBrowserBreakdownRow struct {
	Browser pgtype.Text
	Views   int64
}

// QueryBrowserBreakdown
//
//	select browser, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	group by browser order by views desc
func (q *Queries) QueryBrowserBreakdown(ctx context.Context, db DBTX, arg QueryBrowserBreakdownParams) ([]QueryBrowserBreakdownRow, error) {
	rows, err := db.Query(ctx, queryBrowserBreakdown, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryBrowserBreakdownRow
	for rows.Next() {
		var i QueryBrowserBreakdownRow
		if err := rows.Scan(&i.Browser, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryDeviceBreakdown = `-- name: QueryDeviceBreakdown :many
select device, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
group by device order by views desc
`

type QueryDeviceBreakdownParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryDeviceBreakdownRow struct {
	Device pgtype.Text
	Views  int64
}

// QueryDeviceBreakdown
//
//	select device, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	group by device order by views desc
func (q *Queries) QueryDeviceBreakdown(ctx context.Context, db DBTX, arg QueryDeviceBreakdownParams) ([]QueryDeviceBreakdownRow, error) {
	rows, err := db.Query(ctx, queryDeviceBreakdown, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryDeviceBreakdownRow
	for rows.Next() {
		var i QueryDeviceBreakdownRow
		if err := rows.Scan(&i.Device, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryOSBreakdown = `-- name: QueryOSBreakdown :many
select os, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
group by os order by views desc
`

type QueryOSBreakdownParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryOSBreakdownRow struct {
	Os    pgtype.Text
	Views int64
}

// QueryOSBreakdown
//
//	select os, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	group by os order by views desc
func (q *Queries) QueryOSBreakdown(ctx context.Context, db DBTX, arg QueryOSBreakdownParams) ([]QueryOSBreakdownRow, error) {
	rows, err := db.Query(ctx, queryOSBreakdown, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryOSBreakdownRow
	for rows.Next() {
		var i QueryOSBreakdownRow
		if err := rows.Scan(&i.Os, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPageviewsPerDay = `-- name: QueryPageviewsPerDay :many
select date_trunc('day', created_at)::timestamptz as date, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
group by date order by date
`

type QueryPageviewsPerDayParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryPageviewsPerDayRow struct {
	Date  pgtype.Timestamptz
	Views int64
}

// QueryPageviewsPerDay
//
//	select date_trunc('day', created_at)::timestamptz as date, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	group by date order by date
func (q *Queries) QueryPageviewsPerDay(ctx context.Context, db DBTX, arg QueryPageviewsPerDayParams) ([]QueryPageviewsPerDayRow, error) {
	rows, err := db.Query(ctx, queryPageviewsPerDay, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryPageviewsPerDayRow
	for rows.Next() {
		var i QueryPageviewsPerDayRow
		if err := rows.Scan(&i.Date, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPageviewsTimeBucketed = `-- name: QueryPageviewsTimeBucketed :many
select date_trunc($2::text, created_at)::timestamptz as bucket_time,
       count(*)::bigint as views
from pageviews
where website_id = $1
  and created_at between $3::timestamptz and $4::timestamptz
group by bucket_time order by bucket_time
`

type QueryPageviewsTimeBucketedParams struct {
	WebsiteID uuid.UUID
	Bucket    string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryPageviewsTimeBucketedRow struct {
	BucketTime pgtype.Timestamptz
	Views      int64
}

// QueryPageviewsTimeBucketed
//
//	select date_trunc($2::text, created_at)::timestamptz as bucket_time,
//	       count(*)::bigint as views
//	from pageviews
//	where website_id = $1
//	  and created_at between $3::timestamptz and $4::timestamptz
//	group by bucket_time order by bucket_time
func (q *Queries) QueryPageviewsTimeBucketed(ctx context.Context, db DBTX, arg QueryPageviewsTimeBucketedParams) ([]QueryPageviewsTimeBucketedRow, error) {
	rows, err := db.Query(ctx, queryPageviewsTimeBucketed,
		arg.WebsiteID,
		arg.Bucket,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryPageviewsTimeBucketedRow
	for rows.Next() {
		var i QueryPageviewsTimeBucketedRow
		if err := rows.Scan(&i.BucketTime, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopCities = `-- name: QueryTopCities :many
select city, country_code, count(*)::bigint as views
from pageviews
where website_id = $1
  and created_at between $2::timestamptz and $3::timestamptz
  and city is not null and city != ''
group by city, country_code order by views desc limit 10
`

type QueryTopCitiesParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryTopCitiesRow struct {
	City        pgtype.Text
	CountryCode pgtype.Text
	Views       int64
}

// QueryTopCities
//
//	select city, country_code, count(*)::bigint as views
//	from pageviews
//	where website_id = $1
//	  and created_at between $2::timestamptz and $3::timestamptz
//	  and city is not null and city != ''
//	group by city, country_code order by views desc limit 10
func (q *Queries) QueryTopCities(ctx context.Context, db DBTX, arg QueryTopCitiesParams) ([]QueryTopCitiesRow, error) {
	rows, err := db.Query(ctx, queryTopCities, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopCitiesRow
	for rows.Next() {
		var i QueryTopCitiesRow
		if err := rows.Scan(&i.City, &i.CountryCode, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopCountries = `-- name: QueryTopCountries :many
select country_code, country_name, count(*)::bigint as views
from pageviews
where website_id = $1
  and created_at between $2::timestamptz and $3::timestamptz
  and country_code is not null and country_code != ''
group by country_code, country_name order by views desc limit 10
`

type QueryTopCountriesParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryTopCountriesRow struct {
	CountryCode pgtype.Text
	CountryName pgtype.Text
	Views       int64
}

// QueryTopCountries
//
//	select country_code, country_name, count(*)::bigint as views
//	from pageviews
//	where website_id = $1
//	  and created_at between $2::timestamptz and $3::timestamptz
//	  and country_code is not null and country_code != ''
//	group by country_code, country_name order by views desc limit 10
func (q *Queries) QueryTopCountries(ctx context.Context, db DBTX, arg QueryTopCountriesParams) ([]QueryTopCountriesRow, error) {
	rows, err := db.Query(ctx, queryTopCountries, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopCountriesRow
	for rows.Next() {
		var i QueryTopCountriesRow
		if err := rows.Scan(&i.CountryCode, &i.CountryName, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopPages = `-- name: QueryTopPages :many
select url, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
group by url order by views desc limit 10
`

type QueryTopPagesParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryTopPagesRow struct {
	Url   string
	Views int64
}

// QueryTopPages
//
//	select url, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	group by url order by views desc limit 10
func (q *Queries) QueryTopPages(ctx context.Context, db DBTX, arg QueryTopPagesParams) ([]QueryTopPagesRow, error) {
	rows, err := db.Query(ctx, queryTopPages, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopPagesRow
	for rows.Next() {
		var i QueryTopPagesRow
		if err := rows.Scan(&i.Url, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopReferrers = `-- name: QueryTopReferrers :many
select referrer, count(*)::bigint as views
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
  and referrer is not null and referrer != ''
group by referrer order by views desc limit 10
`

type QueryTopReferrersParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryTopReferrersRow struct {
	Referrer pgtype.Text
	Views    int64
}

// QueryTopReferrers
//
//	select referrer, count(*)::bigint as views
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
//	  and referrer is not null and referrer != ''
//	group by referrer order by views desc limit 10
func (q *Queries) QueryTopReferrers(ctx context.Context, db DBTX, arg QueryTopReferrersParams) ([]QueryTopReferrersRow, error) {
	rows, err := db.Query(ctx, queryTopReferrers, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopReferrersRow
	for rows.Next() {
		var i QueryTopReferrersRow
		if err := rows.Scan(&i.Referrer, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTotalPageviews = `-- name: QueryTotalPageviews :one
select count(*)::bigint as total
from pageviews
where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
`

type QueryTotalPageviewsParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

// QueryTotalPageviews
//
//	select count(*)::bigint as total
//	from pageviews
//	where website_id = $1 and created_at between $2::timestamptz and $3::timestamptz
func (q *Queries) QueryTotalPageviews(ctx context.Context, db DBTX, arg QueryTotalPageviewsParams) (int64, error) {
	row := db.QueryRow(ctx, queryTotalPageviews, arg.WebsiteID, arg.StartDate, arg.EndDate)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const queryTotalUniqueVisitors = `-- name: QueryTotalUniqueVisitors :one
select count(distinct visitor_hash)::bigint as total
from pageviews
where website_id = $1
  and created_at between $2::timestamptz and $3::timestamptz
  and visitor_hash is not null
`

type QueryTotalUniqueVisitorsParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

// QueryTotalUniqueVisitors
//
//	select count(distinct visitor_hash)::bigint as total
//	from pageviews
//	where website_id = $1
//	  and created_at between $2::timestamptz and $3::timestamptz
//	  and visitor_hash is not null
func (q *Queries) QueryTotalUniqueVisitors(ctx context.Context, db DBTX, arg QueryTotalUniqueVisitorsParams) (int64, error) {
	row := db.QueryRow(ctx, queryTotalUniqueVisitors, arg.WebsiteID, arg.StartDate, arg.EndDate)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const queryUniqueVisitorsTimeBucketed = `-- name: QueryUniqueVisitorsTimeBucketed :many
select date_trunc($2::text, created_at)::timestamptz as bucket_time,
       count(distinct visitor_hash)::bigint as visitors
from pageviews
where website_id = $1
  and created_at between $3::timestamptz and $4::timestamptz
  and visitor_hash is not null
group by bucket_time order by bucket_time
`

type QueryUniqueVisitorsTimeBucketedParams struct {
	WebsiteID uuid.UUID
	Bucket    string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryUniqueVisitorsTimeBucketedRow struct {
	BucketTime pgtype.Timestamptz
	Visitors   int64
}

// QueryUniqueVisitorsTimeBucketed
//
//	select date_trunc($2::text, created_at)::timestamptz as bucket_time,
//	       count(distinct visitor_hash)::bigint as visitors
//	from pageviews
//	where website_id = $1
//	  and created_at between $3::timestamptz and $4::timestamptz
//	  and visitor_hash is not null
//	group by bucket_time order by bucket_time
func (q *Queries) QueryUniqueVisitorsTimeBucketed(ctx context.Context, db DBTX, arg QueryUniqueVisitorsTimeBucketedParams) ([]QueryUniqueVisitorsTimeBucketedRow, error) {
	rows, err := db.Query(ctx, queryUniqueVisitorsTimeBucketed,
		arg.WebsiteID,
		arg.Bucket,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryUniqueVisitorsTimeBucketedRow
	for rows.Next() {
		var i QueryUniqueVisitorsTimeBucketedRow
		if err := rows.Scan(&i.BucketTime, &i.Visitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
