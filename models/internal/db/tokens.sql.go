// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tokens.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countTokens = `-- name: CountTokens :one
select count(*) from tokens
`

// CountTokens
//
//	select count(*) from tokens
func (q *Queries) CountTokens(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countTokens)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteToken = `-- name: DeleteToken :exec
delete from tokens where id=$1
`

// DeleteToken
//
//	delete from tokens where id=$1
func (q *Queries) DeleteToken(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteToken, id)
	return err
}

const insertToken = `-- name: InsertToken :one
insert into
    tokens (id, created_at, updated_at, scope, expires_at, hash, meta_data)
values
    ($1, now(), now(), $2, $3, $4, $5)
returning id, created_at, updated_at, scope, expires_at, hash, meta_data
`

type InsertTokenParams struct {
	ID        uuid.UUID
	Scope     string
	ExpiresAt pgtype.Timestamptz
	Hash      string
	MetaData  []byte
}

// InsertToken
//
//	insert into
//	    tokens (id, created_at, updated_at, scope, expires_at, hash, meta_data)
//	values
//	    ($1, now(), now(), $2, $3, $4, $5)
//	returning id, created_at, updated_at, scope, expires_at, hash, meta_data
func (q *Queries) InsertToken(ctx context.Context, db DBTX, arg InsertTokenParams) (Token, error) {
	row := db.QueryRow(ctx, insertToken,
		arg.ID,
		arg.Scope,
		arg.ExpiresAt,
		arg.Hash,
		arg.MetaData,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scope,
		&i.ExpiresAt,
		&i.Hash,
		&i.MetaData,
	)
	return i, err
}

const queryPaginatedTokens = `-- name: QueryPaginatedTokens :many
select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedTokensParams struct {
	Offset int64
	Limit  int64
}

// QueryPaginatedTokens
//
//	select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens
//	order by created_at desc
//	limit $2::bigint offset $1::bigint
func (q *Queries) QueryPaginatedTokens(ctx context.Context, db DBTX, arg QueryPaginatedTokensParams) ([]Token, error) {
	rows, err := db.Query(ctx, queryPaginatedTokens, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Scope,
			&i.ExpiresAt,
			&i.Hash,
			&i.MetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTokenByID = `-- name: QueryTokenByID :one
select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens where id=$1
`

// QueryTokenByID
//
//	select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens where id=$1
func (q *Queries) QueryTokenByID(ctx context.Context, db DBTX, id uuid.UUID) (Token, error) {
	row := db.QueryRow(ctx, queryTokenByID, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scope,
		&i.ExpiresAt,
		&i.Hash,
		&i.MetaData,
	)
	return i, err
}

const queryTokenByScopeAndHash = `-- name: QueryTokenByScopeAndHash :one
select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens where scope=$1 and hash=$2 limit 1
`

type QueryTokenByScopeAndHashParams struct {
	Scope string
	Hash  string
}

// QueryTokenByScopeAndHash
//
//	select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens where scope=$1 and hash=$2 limit 1
func (q *Queries) QueryTokenByScopeAndHash(ctx context.Context, db DBTX, arg QueryTokenByScopeAndHashParams) (Token, error) {
	row := db.QueryRow(ctx, queryTokenByScopeAndHash, arg.Scope, arg.Hash)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scope,
		&i.ExpiresAt,
		&i.Hash,
		&i.MetaData,
	)
	return i, err
}

const queryTokens = `-- name: QueryTokens :many
select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens
`

// QueryTokens
//
//	select id, created_at, updated_at, scope, expires_at, hash, meta_data from tokens
func (q *Queries) QueryTokens(ctx context.Context, db DBTX) ([]Token, error) {
	rows, err := db.Query(ctx, queryTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Scope,
			&i.ExpiresAt,
			&i.Hash,
			&i.MetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToken = `-- name: UpdateToken :one
update tokens
    set updated_at=now(), scope=$2, expires_at=$3, hash=$4, meta_data=$5
where id = $1
returning id, created_at, updated_at, scope, expires_at, hash, meta_data
`

type UpdateTokenParams struct {
	ID        uuid.UUID
	Scope     string
	ExpiresAt pgtype.Timestamptz
	Hash      string
	MetaData  []byte
}

// UpdateToken
//
//	update tokens
//	    set updated_at=now(), scope=$2, expires_at=$3, hash=$4, meta_data=$5
//	where id = $1
//	returning id, created_at, updated_at, scope, expires_at, hash, meta_data
func (q *Queries) UpdateToken(ctx context.Context, db DBTX, arg UpdateTokenParams) (Token, error) {
	row := db.QueryRow(ctx, updateToken,
		arg.ID,
		arg.Scope,
		arg.ExpiresAt,
		arg.Hash,
		arg.MetaData,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scope,
		&i.ExpiresAt,
		&i.Hash,
		&i.MetaData,
	)
	return i, err
}
