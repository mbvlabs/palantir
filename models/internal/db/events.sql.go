// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const insertEvent = `-- name: InsertEvent :one
insert into
    events (id, created_at, website_id, url, event_name, event_data, visitor_hash, country_code, country_name, city, region)
values
    ($1, now(), $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, created_at, website_id, url, event_name, event_data, visitor_hash, country_code, country_name, city, region
`

type InsertEventParams struct {
	ID          uuid.UUID
	WebsiteID   uuid.UUID
	Url         string
	EventName   string
	EventData   []byte
	VisitorHash pgtype.Text
	CountryCode pgtype.Text
	CountryName pgtype.Text
	City        pgtype.Text
	Region      pgtype.Text
}

// InsertEvent
//
//	insert into
//	    events (id, created_at, website_id, url, event_name, event_data, visitor_hash, country_code, country_name, city, region)
//	values
//	    ($1, now(), $2, $3, $4, $5, $6, $7, $8, $9, $10)
//	returning id, created_at, website_id, url, event_name, event_data, visitor_hash, country_code, country_name, city, region
func (q *Queries) InsertEvent(ctx context.Context, db DBTX, arg InsertEventParams) (Event, error) {
	row := db.QueryRow(ctx, insertEvent,
		arg.ID,
		arg.WebsiteID,
		arg.Url,
		arg.EventName,
		arg.EventData,
		arg.VisitorHash,
		arg.CountryCode,
		arg.CountryName,
		arg.City,
		arg.Region,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.WebsiteID,
		&i.Url,
		&i.EventName,
		&i.EventData,
		&i.VisitorHash,
		&i.CountryCode,
		&i.CountryName,
		&i.City,
		&i.Region,
	)
	return i, err
}

const queryEventsTimeBucketed = `-- name: QueryEventsTimeBucketed :many
select date_trunc($2::text, created_at)::timestamptz as bucket_time,
       count(*)::bigint as event_count
from events
where website_id = $1
  and created_at between $3::timestamptz and $4::timestamptz
group by bucket_time order by bucket_time
`

type QueryEventsTimeBucketedParams struct {
	WebsiteID uuid.UUID
	Bucket    string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryEventsTimeBucketedRow struct {
	BucketTime pgtype.Timestamptz
	EventCount int64
}

// QueryEventsTimeBucketed
//
//	select date_trunc($2::text, created_at)::timestamptz as bucket_time,
//	       count(*)::bigint as event_count
//	from events
//	where website_id = $1
//	  and created_at between $3::timestamptz and $4::timestamptz
//	group by bucket_time order by bucket_time
func (q *Queries) QueryEventsTimeBucketed(ctx context.Context, db DBTX, arg QueryEventsTimeBucketedParams) ([]QueryEventsTimeBucketedRow, error) {
	rows, err := db.Query(ctx, queryEventsTimeBucketed,
		arg.WebsiteID,
		arg.Bucket,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryEventsTimeBucketedRow
	for rows.Next() {
		var i QueryEventsTimeBucketedRow
		if err := rows.Scan(&i.BucketTime, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopEvents = `-- name: QueryTopEvents :many
select event_name, count(*)::bigint as event_count
from events
where website_id = $1
  and created_at between $2::timestamptz and $3::timestamptz
group by event_name order by event_count desc limit 10
`

type QueryTopEventsParams struct {
	WebsiteID uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type QueryTopEventsRow struct {
	EventName  string
	EventCount int64
}

// QueryTopEvents
//
//	select event_name, count(*)::bigint as event_count
//	from events
//	where website_id = $1
//	  and created_at between $2::timestamptz and $3::timestamptz
//	group by event_name order by event_count desc limit 10
func (q *Queries) QueryTopEvents(ctx context.Context, db DBTX, arg QueryTopEventsParams) ([]QueryTopEventsRow, error) {
	rows, err := db.Query(ctx, queryTopEvents, arg.WebsiteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopEventsRow
	for rows.Next() {
		var i QueryTopEventsRow
		if err := rows.Scan(&i.EventName, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
