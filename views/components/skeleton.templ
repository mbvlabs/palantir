package components

type SkeletonBuilder struct {
	id         string
	class      string
	classOverride bool
	attrs      templ.Attributes
	fragmentID string
}

// Skeleton renders an animated placeholder block to indicate loading content. Use it as
// a stand-in for text, images, or cards while data is being fetched. Set dimensions
// via WithClass (e.g., "h-4 w-48" for a text line, "h-12 w-12 rounded-full" for an avatar).
//
//	@components.Skeleton().WithClass("h-4 w-[200px]").Render()
//	@components.Skeleton().WithClass("h-12 w-12 rounded-full").Render()
func Skeleton() *SkeletonBuilder {
	return &SkeletonBuilder{}
}

func (b *SkeletonBuilder) WithID(id string) *SkeletonBuilder   { b.id = id; return b }
func (b *SkeletonBuilder) WithClass(c string) *SkeletonBuilder { b.class = cn(b.class, c); return b }
func (b *SkeletonBuilder) SetClass(c string) *SkeletonBuilder  { b.class = c; b.classOverride = true; return b }
func (b *SkeletonBuilder) WithAttr(key string, val any) *SkeletonBuilder {
	if b.attrs == nil {
		b.attrs = templ.Attributes{}
	}
	b.attrs[key] = val
	return b
}
func (b *SkeletonBuilder) WithFragment(id string) *SkeletonBuilder { b.fragmentID = id; return b }

func skeletonClasses(b *SkeletonBuilder) string {
	base := "animate-pulse rounded-field bg-base-300"
	return mergeClass(cn(base), b.class, b.classOverride)
}

templ (b *SkeletonBuilder) Render() {
	if b.fragmentID != "" {
		@templ.Fragment(b.fragmentID) {
			@b.render()
		}
	} else {
		@b.render()
	}
}

templ (b *SkeletonBuilder) render() {
	<div
		class={ skeletonClasses(b) }
		if b.id != "" {
			id={ b.id }
		}
		if b.attrs != nil {
			{ b.attrs... }
		}
	></div>
}
